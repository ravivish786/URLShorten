using Microsoft.EntityFrameworkCore;
using URLShorten.Database;
using URLShorten.Dto;
using URLShorten.Interface;

namespace URLShorten.Service
{
    public class UrlManagerService : IUrlManager
    {
        private readonly AppDbContext _context;

        public UrlManagerService(AppDbContext context)
        {
            _context = context;
        }

        public async Task<Result<List<ShortUrlDto>>> GetAllAsync(CancellationToken cancellationToken)
        {
            var data = await _context.ShortUrls.ToListAsync(cancellationToken);
            if (data == null || !data.Any())
            {
                return Result<List<ShortUrlDto>>.Fail("No short URLs found.");
            }
            var result = data.Select(MapData).ToList();
            return Result<List<ShortUrlDto>>.Ok(result, "Short URLs retrieved successfully.");
        }

        public async Task<Result<ShortUrlDto>> GetAsync(string shortUrl, CancellationToken cancellationToken)
        {
            var data = await _context.ShortUrls.FirstOrDefaultAsync(x => x.ShortCode == shortUrl, cancellationToken);
            if (data == null)
            {
                return Result<ShortUrlDto>.Fail("Short URL not found.");
            }

            var statistics = await _context.UrlStatistics
                .FirstOrDefaultAsync(x => x.ShortUrl == shortUrl && x.DateTime.Date == DateTime.UtcNow.Date , cancellationToken);
            
            if (statistics == null)
            {
                _context.UrlStatistics.Add(new UrlStatistics
                {
                    ShortUrl = shortUrl,
                    DateTime = DateTime.UtcNow,
                    Hits = 1,
                    Id = GetNextIdForStatistic()
                });
            }
            else
            {
                statistics.Hits += 1;
            }

            
            //_context.ShortUrls.Update(data);
            await _context.SaveChangesAsync(cancellationToken);
            return Result<ShortUrlDto>.Ok(MapData(data), "Short URL retrieved successfully.");
        }

        public async Task<Result<ShortUrlStatisticsDto>> GetStatisticsAsync(string shortUrl, CancellationToken cancellationToken)
        {
            var data = await _context.ShortUrls
                .Include(x => x.Statistics)
                .FirstOrDefaultAsync(x => x.ShortCode == shortUrl, cancellationToken);

            if (data == null)
            {
                return Result<ShortUrlStatisticsDto>.Fail("Short URL not found.");
            }

            var statistics = _context.UrlStatistics.Where(x => x.ShortUrl == shortUrl);

            int total = statistics.Sum(x => x.Hits);

            var map = MapStatisticsData(data);
            map.AccessCount = total;
            map.GraphData = total > 0
                ? statistics.Select(x => new GraphDataDto
                {
                    Date = x.DateTime.ToString("yyyy-MM-dd"),
                    Hits = x.Hits
                }).ToList()
                : new List<GraphDataDto>();
            return Result<ShortUrlStatisticsDto>.Ok(map, "Short URL statistics retrieved successfully.");
        }


        public async Task<Result<ShortUrlDto>> CreateAsync(string longUrl, CancellationToken cancellationToken)
        {
            var entity = new ShortUrl
            {
                Url = longUrl,
                ShortCode = GenerateShortUrl(),
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = null,
                //AccessCount = 0,
                Id = GetNextId() // Assuming Id is auto-generated by the database 
            };
            _context.ShortUrls.Add(entity);
            await _context.SaveChangesAsync(cancellationToken);
            return Result<ShortUrlDto>.Ok(MapData(entity), "Short URL created successfully.");
        }

        public async Task<Result<ShortUrlDto>> UpdateAsync(string shortUrl, string longUrl, CancellationToken cancellationToken)
        {
            var data = await _context.ShortUrls.FirstOrDefaultAsync(x => x.ShortCode == shortUrl, cancellationToken);
            if (data == null)
            {
                return Result<ShortUrlDto>.Fail("Short URL not found.");
            }
            var entity = data;
            entity.Url = longUrl;
            entity.UpdatedAt = DateTime.UtcNow;
            _context.ShortUrls.Update(entity);
            await _context.SaveChangesAsync(cancellationToken);
            return Result<ShortUrlDto>.Ok(MapData(entity), "Short URL updated successfully.");
        }

        public async Task<Result<bool>> DeleteAsync(string shortUrl, CancellationToken cancellationToken)
        {
            var data = await _context.ShortUrls.FirstOrDefaultAsync(x => x.ShortCode == shortUrl, cancellationToken);
            if (data == null)
            {
                return Result<bool>.Fail("Short URL not found.");
            }
            _context.ShortUrls.Remove(data);
            var status = await _context.SaveChangesAsync(cancellationToken) > 0;
            return Result<bool>.Ok(status, status ? "Short URL deleted successfully." : "Failed to delete Short URL.");
        }





        #region Utility Methods

        private ShortUrlDto MapData(ShortUrl entity)
        {
            return new ShortUrlDto
            {
                Id = entity.Id,
                Url = entity.Url,
                ShortCode = entity.ShortCode,
                CreatedAt = entity.CreatedAt,
                UpdatedAt = entity.UpdatedAt
            };
        }


        private ShortUrlStatisticsDto MapStatisticsData(ShortUrl entity)
        {
            return new ShortUrlStatisticsDto
            {
                Id = entity.Id,
                Url = entity.Url,
                ShortCode = entity.ShortCode,
                CreatedAt = entity.CreatedAt,
                UpdatedAt = entity.UpdatedAt,
                //AccessCount = entity.AccessCount
            };
        }

        private int GetNextId()
        {
            // This method should return the next available ID for a new ShortUrl.
            // In a real application, this would typically be handled by the database.
            return _context.ShortUrls.Any() ? _context.ShortUrls.Max(s => s.Id) + 1 : 1;
        }

        private int GetNextIdForStatistic()
        {
            // This method should return the next available ID for a new ShortUrl.
            // In a real application, this would typically be handled by the database.
            return _context.UrlStatistics.Any() ? _context.UrlStatistics.Max(s => s.Id) + 1 : 1;
        }

        private string GenerateShortUrl()
        {
            long tickes = DateTime.UtcNow.Ticks;
            string base64 = Convert.ToBase64String(BitConverter.GetBytes(tickes));
            base64 = base64.Replace("/", "_").Replace("+", "-").TrimEnd('=');
            return base64;
        }

        #endregion
    }
}
